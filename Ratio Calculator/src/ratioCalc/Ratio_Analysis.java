package ratioCalc;
import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.Prefs;
import ij.WindowManager;
import ij.gui.GenericDialog;
import ij.gui.NewImage;
import ij.io.DirectoryChooser;
import ij.io.FileSaver;
import ij.io.OpenDialog;
import ij.io.Opener;
import ij.measure.ResultsTable;
import ij.plugin.MontageMaker;
import ij.plugin.PlugIn;
import ij.process.FloatProcessor;
import ij.process.ImageProcessor;
import ij.process.ImageStatistics;
import ij.text.TextPanel;

import java.io.IOException;
import java.util.ArrayList;

// _____________________________________________________________________________________________________________
//
// --------------------
// Ratio Analysis v1.35
// --------------------
//
// Till Andlauer (till@andlauer.net)
// Date: 11-10-xx - 13-08-21
//
// Calculates various plots for data generated by Ratio Calculator. Actual plots can be generated with GnuPlot.
//
// Uncertainties for medians:
// Median Absolute Deviation    = The median of the differences of the individual values to the median              
// Standard Error of the Median = s = (a-b) / 3.4641; a = (n/2 + sqrt(3n)/n) th observation, b = (n/2 - sqrt(3n)/n) th observation, rounded up to the next number 
// Source: Lothar Sachs, Angewandte Statistik, 11. Auflage 2003, S. 160.
//
// Error propagation according to: Lothar Papula, Mathematik für Ingenieure und Naturwissenschaftler Band 3, 5. Auflage 2008, Kapitel 4.3, Seite 678ff: Gaußsches Fehlerfortpflanzungsgesetz
// Sum of two values X,Y with uncertainties sX,sY:        e = SQRT((sX/2)^2 + (sY/2)^2))
// Sum of three values X,Y,Z with uncertainties sX,sY,sZ: e = SQRT((sX/3)^2 + (sY/3)^2 + (sZ/3)^2))
// Division of two values X,Y with uncertainties sX,sY:        e = SQRT((sX/X)^2 + (sY/Y)^2))
// Division of three values X,Y,Z with uncertainties sX,sY,sZ: e = SQRT((sX/Y)^2 + (sY/Y)^2 + (sZ/Z)^2))
//
// Current format of statistics files:
// -----------------------------------
// 1-1 Line 1: Min,Q1,Median,Q3,Max; line 2: SEMs/MADs
// 1-2 Min + SEM/MAD
// 1-3 Q1 + SEM/MAD
// 1-4 Median + SEM/MAD
// 1-5 Q3 + SEM/MAD
// 1-6 Max + SEM/MAD
// 2   Line 1: Q1 + SEM/MAD; line 2: Median + SEM/MAD; line 3: Q3 + SEM/MAD
// 3   Line 1: Min,Q1,Median,Q3,Max; line 2: SEMs/MADs; line 3: combined Min,Q1,Median,Q3,Max            
// 4   All data samples combined in one file or Mann-Whitney-U test results            
//
// Version history
// xxxxxxxxxxxxxxx
//
// v1.31
// Added support for Mann-Whitney U-tests via the jsc.jar classes (A.J. Bertie, http://www.jsc.nildram.co.uk/)
//
// v1.32 - final version used for ratio analysis
// Maintenance, compatibility adaptations, added comments, bug fixes (error propagation, normalized statistics)
// Because normalized statistics is currently disabled, this option has not been tested and might contain bugs.
//
// v1.33
// Added Fingerprints.
//
// v1.34
// Added Proportions.
// Added Subtraction of Histograms.
// Overhauled normalized statistics.
// Implemented use of the separate classes Ratio_InOut, Ratio_Statistics and Gnu_Scripts.
// Removed jsc.jar classes. Use of Apache Commons instead.
//
// v1.35
// Misc. optimizations.
//
// _____________________________________________________________________________________________________________

public class Ratio_Analysis implements PlugIn
    {   
    private String title = "Ratio Analysis v1.35";
    private String saveError = "Couldn't save file.";
    private boolean all = false; // job=3
    private boolean overview = false; // job=6
    // All of the following options can be set in chooseImages():
    private int job = 8; // type of analysis to run; 0 = Histograms, 1 = Statistics, 2 = Scatter plots, 3 = All basic plots, 4 = comparative statistics, 5 = normalized statistics, 6 = histograms overview, 7 = fingerprint, 8 = proportions
    private int nFiles = 8; // number of files to be opened
    private boolean sd = true; // calculate/show standard errors
    private boolean statsMean = true; // use mean instead of median for statistics
    private boolean stats_mad = false; // use MAD (median absolute deviation) for statistics
    private boolean histo_med = false; // use median for histograms
    private String plottitle = "Ratios";
    private String axislabel = "ratios";
    private String directory = ij.Prefs.getHomeDir()+Prefs.getFileSeparator(); // directory for saving files manually
    private String inputFile = "00 Statistics Summary 1-1.xls"; // file to load for fingerprinting
    private boolean screen = true; // show results on screen
    private String terminal = "aqua"; // output of data (aqua/x11/windows/wxt)
    private boolean svg = true; // create .svg file
    private boolean png = true; // create .png file

    private String[] xTitle = new String[nFiles]; // x-labels for the different files (statistics)
    private String[] refFiles; // files for the normalized statistics

    public void run(String arg) 
        {  
    	boolean success = loadConfig();
        success = fileDialog();
        if (!success) return;

        if (all || job==0 || job==1 || job==2) success = basicAnalysis();
        else if (job==4) success = compAnalysis();
        else if (job==5) success = normAnalysis();
        else if (job==7) success = fingerAnalysis();
        else if (job==8) success = propAnalysis();
        else if (job==9) success = subtractHistos();
        }

    
    private boolean loadConfig()
    	{
    	Ratio_Config rc;
		rc = new Ratio_Config();
		if (rc.error) return false;
		else
			{
			String[] ints = {"job", "nFiles"};
			String[] strings = {"plottitle", "axislabel", "terminal", "directory"};
			String[] booleans = {"sd", "statsMean", "stats_mad", "histo_med", "screen", "svg", "png"};
			int cInt = 0;
			String cString = "";
			boolean cBool = false;
			
	    	cInt = rc.getInt(ints[0]);
	    	if (!rc.error) job=cInt;
	    	else rc.error=false;
	    	cInt = rc.getInt(ints[1]);
	    	if (!rc.error) nFiles=cInt;
	    	else rc.error=false;

	    	cString = rc.getValue(strings[0]);
	    	if (!rc.error) plottitle=cString;
	    	else rc.error=false;
	    	cString = rc.getValue(strings[1]);
	    	if (!rc.error) axislabel=cString;
	    	else rc.error=false;
	    	cString = rc.getValue(strings[2]);
	    	if (!rc.error) terminal=cString;
	    	else rc.error=false;
	    	cString = rc.getValue(strings[3]);
	    	if (!rc.error) directory=cString;
	    	else rc.error=false;
			
	    	cBool = rc.getBoolean(booleans[0]);
	    	if (!rc.error) sd=cBool;
	    	else rc.error=false;
	    	cBool = rc.getBoolean(booleans[1]);
	    	if (!rc.error) statsMean=cBool;
	    	else rc.error=false;
	    	cBool = rc.getBoolean(booleans[2]);
	    	if (!rc.error) stats_mad=cBool;
	    	else rc.error=false;
	    	cBool = rc.getBoolean(booleans[3]);
	    	if (!rc.error) histo_med=cBool;
	    	else rc.error=false;
	    	cBool = rc.getBoolean(booleans[4]);
	    	if (!rc.error) screen=cBool;
	    	else rc.error=false;
	    	cBool = rc.getBoolean(booleans[5]);
	    	if (!rc.error) svg=cBool;
	    	else rc.error=false;
	    	cBool = rc.getBoolean(booleans[6]);
	    	if (!rc.error) png=cBool;
	    	else rc.error=false;
			}
		return true;
    	}
    
    
    public boolean propAnalysis() // calculate proportions
	    {
	    Ratio_InOut rio = new Ratio_InOut(nFiles, directory);
	    int[][] data = rio.loadHistoFiles("Original Data"); // all histogram files; [bins][files]
	    if (data==null) return false;
	    int[] count = new int[3];
	    double[][] proportion = new double[data[0].length][3];
	    int[] limit = {18834,20762}; // 18834 = 0.95, 20762 = 1.05, 39641 = max = data.length
	    int[] sum = new int[data[0].length];
	
	    for (int i=0;i<data[0].length;i++)
	        {
	    	for (int j=0;j<data.length;j++)
	        	{
	    		if (j < limit[0]-1) count[0] += data[j][i];
	    		else if (j > limit[1]-1) count[2] += data[j][i];
	    		else count[1] += data[j][i];
	        	}
	    	sum[i] = count[0]+count[1]+count[2];
	        proportion[i][0] = 1.0d * count[0] / sum[i];
	        proportion[i][1] = 1.0d * count[1] / sum[i];
	        proportion[i][2] = 1.0d * count[2] / sum[i];
	        count[0] = count[1] = count[2] = 0;
	    	}
	
	    double[] meanProp = new double[4];
	    double[] dSum = new double[4];
	    
	    for (int i=0;i<data[0].length;i++)
	    	{
	    	dSum[0] += proportion[i][0];
	    	dSum[1] += proportion[i][1];
	    	dSum[2] += proportion[i][2];
	    	dSum[3] += sum[i];
	    	}
		meanProp[0] = dSum[0] / data[0].length;
		meanProp[1] = dSum[1] / data[0].length;
		meanProp[2] = dSum[2] / data[0].length;
		meanProp[3] = dSum[3] / data[0].length;
	    			
	    ResultsTable rt = ResultsTable.getResultsTable(); // for the output data
	    rt.reset();
	    rt.setPrecision(9);
	    rt.incrementCounter();
	    rt.addValue("low", meanProp[0]);    
	    rt.addValue("balanced", meanProp[1]);    
	    rt.addValue("high", meanProp[2]);   
	    rt.addValue("pixel", meanProp[3]);   
	    rt.incrementCounter();
	
	    for (int i=0;i<data[0].length;i++)
	    	{
	        rt.incrementCounter();
	        rt.addValue("low", proportion[i][0]);    
	        rt.addValue("balanced", proportion[i][1]);    
	        rt.addValue("high", proportion[i][2]);   
	        rt.addValue("pixel", sum[i]);   
	    	}
	    
	    try
	        {
	        rt.saveAs(directory+"00 Proportions.xls");    
	        }
	    catch (IOException e) 
	        {
	        IJ.error(saveError); 
	        return false;
	        } 
	    return true;
	  	} // end of propAnalysis()

    
    /**
     * Generates bins for fingerprinting (for mapping of -1/0/+1 ratio to values ranging from 0-255).
     *
     * @return the double[]
     */
    private double[] generateBins()
        {
        int size = 127; // the two center values 127,128 are 0, from there values ascend/descend in steps of 1/127 towards 1 and -1.
        double[] matrix = new double[size+size+2]; // 256
        double step = 1.0d/(double)size; // 1/127
        
        for (int i=0; i<size; i++)
            {
        	matrix[size-i-1]=-1.0d * (matrix[size+i+1]+step); // negative values
        	matrix[size+i+2]=matrix[size+i+1]+step; // positive values
            }
        matrix[0]=-1;
        matrix[matrix.length-1]=1;
        
        return matrix;        
        } // end of generateBins()
    

    public boolean fingerAnalysis() // generate fingerprints
	    {
        if ((nFiles % 2)!=0)
        	{
        	IJ.error("Number of files has to be even for calculation of fingerprints.");
        	return false;
        	}
        
       	FileSaver outFile; // for saving Tiffs
	    Ratio_InOut rio = new Ratio_InOut(nFiles, directory);
    
        // Load data
        double[] data = rio.loadFingerprintFile(inputFile);
        if (data==null) return false;
        if ((data.length % 2)!=0)
    		{
        	IJ.error("Number of lines in the file has to be even for calculation of fingerprints.");
        	return false;
    		}
//        double[] data = {-0.166554528, 1, -0.024319011, 1, 0.069004218, 1};
        
        double[] ranks = generateBins();
        double ratio = 0; // the ratio
        int[] print = new int[data.length/2]; // the ratio mapped to values ranging from 0-255
        
        ResultsTable rt = ResultsTable.getResultsTable(); // output
        rt.setPrecision(9);
        rt.reset();
        
        // Calculate ratio values from medians           
        for (int i=0; i<data.length; i+=2)  
            {
            ratio = (Math.abs(data[i+1])-Math.abs(data[i]))/(Math.abs(data[i+1])+Math.abs(data[i])); // (b-a) / (b+a)
//        	ratio = data[i];
        	for (int j=1; j<ranks.length; j++) // find the corresponding bin
            	{
                if (ratio <= ranks[j]) // bin found
            		{
            		if (ratio<0) print[i/2] = j-1; // necessary because 127 and 128 = 0
            		else print[i/2] = j;
            		j=ranks.length; // end loop
            		}
            	}
            rt.incrementCounter(); // write data to table
            rt.addValue("neuropil", data[i]);    
            rt.addValue("gfp", data[i+1]);
            rt.addValue("ratio", ratio);    
            rt.addValue("byte_ratio", print[i/2]+1);                    
            }
        
        inputFile = inputFile.replace(".xls","");
        try // save table
            {
            rt.saveAs(directory+inputFile+" Fingerprints.xls");    
            }
        catch (IOException e) 
            {
            IJ.error(saveError); 
            return false;
            } 

        // generate image
        int height = 50; // height/width of each element
        String imp_out_title = inputFile+" Fingerprints";
        ImagePlus imp_out = NewImage.createByteImage(imp_out_title, print.length*height, height, 1, 1);
        WindowManager.checkForDuplicateName = true; // add a number to the title if name already exists  

        ImageProcessor ip_out = imp_out.getProcessor();
        int bins = print.length;
        int picPos = 0; // counter within image
        int values[] = new int[3]; // red, green, blue
        
        for(int i=0; i<bins; i++)
            {
            for(int j=0; j<height; j++)
                {
                for (int k=0; k<height; k++)
                    {
                    values[0] = print[i];
                    values[1] = print[i];
                    values[2] = print[i];
                    ip_out.putPixel(picPos+k,j,values);
                    }
                }
            picPos = picPos + height; // move to next print
            }

        imp_out.show();
        IJ.run("Ratio Spectrum"); 
    	outFile = new FileSaver(imp_out);
        outFile.saveAsTiff(directory+imp_out.getTitle()+".tif");
        if (!screen) imp_out.close();
        
        return true;
    	} // end of fingAnalysis()
    

    public boolean basicAnalysis() // do all calculations and create the output files
        {
        // Variables used by several jobs
        TextPanel tp; // content of the output files
        String imagename = ""; // name of the images created by the gnuplot scripts
        String filename = ""; // name of the gnuplot script
        Opener inFile = new Opener(); // for opening input Tiffs
        String inputname = ""; // name of the input file
        ImagePlus img_out; // output image
        FileSaver outFile; // for saving Tiffs
        Ratio_InOut rio = new Ratio_InOut(nFiles, directory);
        Gnu_Scripts gs = new Gnu_Scripts(plottitle, axislabel, terminal, sd, screen, svg, png, nFiles, xTitle);
 
        if (job==0 || all) // histograms
            {
            // creates 3 files: the data file 00 Histogram Summary.xls with average histogram values, a gnuplot script and a montage of all histogram plots
           
            if (!overview) // if only the histogram overview should be created, skip this part
                { // merge the histograms from several files into one

            	int[][] data = rio.loadHistoFiles("Histogram"); // all histogram files; [bins][files]
                if (data==null) return false;
                double[] means = new double[data.length]; // mean/median values of all bins
                double[] sem = new double[data.length]; // standard errors for all means

                for (int i=0; i<data.length; i++) // go through bins
                    {
                    if (histo_med) // use medians
                        {
                    	means[i] = Ratio_Statistics.getMedian(data[i], true);
                        if (sd) sem[i] = Ratio_Statistics.getSEMed(data[i]); // calculate standard error of the median
                        }
                    else // use means
                        {
                        means[i] = Ratio_Statistics.getMean(data[i]); // average each bin
                        if (sd) sem[i] = Ratio_Statistics.getSD(data[i], means[i])/Math.sqrt((double)data[0].length); // calculate standard error of the mean
                        }
                    }
    
                ResultsTable rt = ResultsTable.getResultsTable(); // for the output data
                rt.reset();
                rt.setPrecision(9);
                String filename2 = "00 Histogram Summary.xls";
                
                for (int i=0; i<means.length; i++)
                    {
                    rt.incrementCounter();
                    if (histo_med) rt.addValue("Median", means[i]);    
                    else rt.addValue("Mean", means[i]);    
                    if (sd) rt.addValue("SEM", sem[i]);    
                    }
                try
                    {
                    rt.saveAs(directory+filename2);    
                    }
                catch (IOException e) 
                    {
                    IJ.error(saveError); 
                    return false;
                    } 

                imagename = "00 Histogram";
                filename = "histoscript.plt";   
                tp = gs.histoScript(imagename, filename2, false);                    
                tp.saveAs(directory+filename); // write script to file  
                } // end of overview=false
                    
            // make overview (montage)
            ImageStack stack = new ImageStack();
            ImagePlus imp; // temp image for the input histograms as well as the output image
            ImageProcessor ip;
            boolean noFiles = false; // no .tif-files
            for (int i=0; i<nFiles; i++) // combine all histograms into a stack
                {
                if (!noFiles)
	            	{
	                if (i<9) inputname = "0"+(i+1)+" Histogram plot.tif";
	                else inputname = (i+1)+" Histogram plot.tif";          
	                imp = inFile.openTiff(directory, inputname);
	                if (imp==null) noFiles=true;
	                else
	                	{
	                	ip = imp.getProcessor(); 
	                    if (i==0) stack = new ImageStack(ip.getWidth(), ip.getHeight());
	                    stack.addSlice(null, ip); // add histogram to stack
	                	}
                	}
                }
            if (!noFiles)
	        	{
	            imp = new ImagePlus("Histograms", stack); // create image for the stacks          
	            MontageMaker mm = new MontageMaker(); // make a montage of the files
	            int rows = nFiles % 3;
	            if (rows != 0) rows = 4;
	            else rows = 3;
	            if (nFiles < 6) img_out = mm.makeMontage2(imp, nFiles, 1, 0.5, 1, nFiles, 1, 1, false);
	            else if (nFiles == 6) img_out = mm.makeMontage2(imp, 2, 3, 0.5, 1, nFiles, 1, 1, false);
	            else if (nFiles < 11) img_out = mm.makeMontage2(imp, (int)Math.round(nFiles/2.0), 2, 0.5, 1, nFiles, 1, 1, false);
	            else img_out = mm.makeMontage2(imp, (int)Math.round(nFiles/3.0), rows, 0.5, 1, nFiles, 1, 1, false);
	            img_out.setTitle("Histograms");
	            outFile = new FileSaver(img_out);
	            outFile.saveAsTiff(directory+"00 Histograms.tif");
	        	}
	        } // end of job=0 (histograms)
            
        if (job==1 || all) // basic statistics
            {
            // files created:
            // 00 Statistics Summary 4.xls   - list of all original values, one line per file
            // 00 Statistics Summary 3.xls   - Line 1: Min,Q1,Median,Q3,Max; line 2: SEMs/MADs; line 3: combined Min,Q1,Median,Q3,Max            
            // 00 Statistics Summary 1-1.xls - Line 1: Min,Q1,Median,Q3,Max; line 2: SEMs/MADs
            // 00 Statistics Summary 2.xls   - Line 1: Q1 + SEM/MAD; line 2: Median + SEM/MAD; line 3: Q3 + SEM/MAD
            // 00 Statistics Summary 1-2.xls - Min + SEM/MAD (only if sd=true)
            // 00 Statistics Summary 1-3.xls - Q1 + SEM/MAD (only if sd=true)
            // 00 Statistics Summary 1-4.xls - Median + SEM/MAD (only if sd=true)
            // 00 Statistics Summary 1-5.xls - Q3 + SEM/MAD (only if sd=true)
            // 00 Statistics Summary 1-6.xls - Max + SEM/MAD (only if sd=true)
            // statscript1.plt - GnuPlot script box-whisker plot
            // statscript2.plt - GnuPlot script box plot

            // Load data
            double[][] data = rio.loadStatFiles(1, 5, false, "", false); // read 1 line per file, 5 columns per file, don't inverse: data = [data][files], don't add a string to the input name, don't just get the median but all data
            if (data==null) return false;
            double[] median = new double[data.length];
            double[] sem = new double[data.length]; // standard error
            double[] mad = new double[data[0].length]; // used for calculating the median absolute deviation
            double[] invMed = new double[data.length]; // inverse, uniformly distributed values (see below)

            ResultsTable rt = ResultsTable.getResultsTable(); // output
            rt.reset();
            rt.setPrecision(9);
            
            // Create 00 Statistics Summary 4.xls (list of all original values)
            for (int i=0; i<data[0].length; i++) // go through all files
                {
                rt.incrementCounter();
                rt.addValue("Min", data[0][i]);    
                rt.addValue("Q1", data[1][i]);    
                rt.addValue("Med", data[2][i]);    
                rt.addValue("Q3", data[3][i]);    
                rt.addValue("Max", data[4][i]);    
                }
            try
                {
                rt.saveAs(directory+"00 Statistics Summary 4.xls");    
                }
            catch (IOException e) 
                {
                IJ.error(saveError); 
                return false;
                } 

            // Calculate median/mean values and errors/deviations
            // first line: standard results // second line: combined results // third line: inverted results
            // combined results: 
            // show the original value if 0<=value<=1, otherwise 1 + (1 - the inverted value)
            // this way values are uniformly distributed around 1
            // The original values are used for statistics (standard results, line 1)

            
            for (int i=0; i<data.length; i++) // data[x][y]: [x]=min,q1,med,q3,max; [y]=file 
                {
            	if (statsMean)
	            	{
            		median[i] = Ratio_Statistics.getMean(data[i]); // get the mean for each value (min,q1‚median,q3,max)
	            	}
            	else // median
            		{
            		median[i] = Ratio_Statistics.getMedian(data[i], true); // get the median for each value (min,q1‚median,q3,max)
            		}    
                if (median[i]>1) invMed[i] = 1+(1-(1.0d/median[i]));
                else invMed[i] = median[i];

                if (statsMean)
                	{
            		sem[i] = Ratio_Statistics.getSD(data[i],median[i])/Math.sqrt(data[i].length); // get the SEM for each value (min,q1‚median,q3,max)                	
                	}
                else if (stats_mad)
                    {
                    for (int j=0; j<data[0].length; j++) // calc median absolute deviation (mad)
                        {
                        mad[j] = Math.abs(median[i]-data[i][j]); // the difference between the individual values in each file and the median
                        }
	                sem[i] = Ratio_Statistics.getMedian(mad, true); // mad = the median of the differences of the individual values to the median
                    }
                else
                    {
                    sem[i] = Ratio_Statistics.getSEMed(data[i]); // get standard error of the median                      
                    }
                } // from now on the sequences of the values are different from the original files (each column has been sorted individually)

            // Create 00 Statistics Summary 3.xls (Standard results, uncertainties, combined results)
            rt = ResultsTable.getResultsTable(); 
            rt.reset();

            rt.incrementCounter();
            rt.addValue("Min", median[0]);    
            rt.addValue("Q1", median[1]);    
            rt.addValue("Med", median[2]);    
            rt.addValue("Q3", median[3]);    
            rt.addValue("Max", median[4]);    
            rt.incrementCounter();
            rt.addValue("Min", sem[0]);    
            rt.addValue("Q1", sem[1]);    
            rt.addValue("Med", sem[2]);    
            rt.addValue("Q3", sem[3]);    
            rt.addValue("Max", sem[4]);    
            rt.incrementCounter();
            rt.addValue("Min", invMed[0]);    
            rt.addValue("Q1", invMed[1]);    
            rt.addValue("Med", invMed[2]);    
            rt.addValue("Q3", invMed[3]);    
            rt.addValue("Max", invMed[4]);    

            try
                {
                rt.saveAs(directory+"00 Statistics Summary 3.xls");    
                }
            catch (IOException e) 
                {
                IJ.error(saveError); 
                return false;
                } 

            // 00 Statistics Summary 1-1.xls - Line 1: Min,Q1,Median,Q3,Max; line 2: SEMs/MADs
            rt.reset();
            rt.incrementCounter();
            rt.addValue("Min", median[0]);    
            rt.addValue("Q1", median[1]);    
            rt.addValue("Med", median[2]);    
            rt.addValue("Q3", median[3]);    
            rt.addValue("Max", median[4]);    

            rt.incrementCounter();
            rt.addValue("Min", sem[0]);    
            rt.addValue("Q1", sem[1]);    
            rt.addValue("Med", sem[2]);    
            rt.addValue("Q3", sem[3]);    
            rt.addValue("Max", sem[4]);    

            try
                {
                rt.saveAs(directory+"00 Statistics Summary 1-1.xls");    
                }
            catch (IOException e) 
                {
                IJ.error(saveError); 
                return false;
                } 

            // 00 Statistics Summary 2.xls - Line 1: Q1 + SEM/MAD; line 2: Median + SEM/MAD; line 3: Q3 + SEM/MAD
            rt.reset();
            for (int i=1; i<median.length-1; i++)
                {
                rt.incrementCounter();
                rt.addValue("Median", median[i]);    
                if (stats_mad) rt.addValue("MAD", sem[i]);
                else rt.addValue("SEM", sem[i]);
                }
            try
                {
                rt.saveAs(directory+"00 Statistics Summary 2.xls");    
                }
            catch (IOException e) 
                {
                IJ.error(saveError); 
                return false;
                } 

            // 00 Statistics Summary 1-2 - 1-6.xls - results + SEM/MAD
            if (sd) // only if SEM/MAD should be plotted
                {            
                for (int i=0; i<median.length; i++)
                    {
                    rt.reset();
                    rt.incrementCounter();
                    rt.addValue("Median", median[i]);    
                    if (stats_mad) rt.addValue("MAD", sem[i]);
                    else rt.addValue("SEM", sem[i]);
                    try
                        {
                        rt.saveAs(directory+"00 Statistics Summary 1-"+(i+2)+".xls");    
                        }
                    catch (IOException e) 
                        {
                        IJ.error(saveError); 
                        return false;
                        } 
                    }
                }

            // create gnuplot script 1: box-whisker plot
            imagename = "00 Statistics 1";
            filename = "statscript1.plt";
            tp = gs.statScript1(imagename);                    
            tp.saveAs(directory+filename); // end of statscript1.plt

            // create gnuplot script 2: box plot
            imagename = "00 Statistics 2";
            filename = "statscript2.plt";
            tp = gs.statScript2(imagename);                    
            tp.saveAs(directory+filename); // end of statscript2.plt            
            } // end of job 1 (statistics)
        
        if (job == 2 || all) // combines all scatter plots into one scatter plot
            {
            // 3 files: combined scatter plot tiff, text data file and gnuplot script
            ImagePlus[] img = new ImagePlus[nFiles];
            for (int i=0; i<nFiles; i++)
                {
                if (i<9) inputname = "0"+(i+1)+" Scatter plot.tif";
                else inputname = (i+1)+" Scatter plot.tif";          
                img[i] = inFile.openTiff(directory, inputname); 
                if (img[i]==null) return false;
                }
            img_out = averagePlots(img); // create the combined scatter plot
            if (img_out == null) return false;
            if (screen) img_out.show();
            outFile = new FileSaver(img_out);
            outFile.saveAsTiff(directory+"00 Scatter plot.tif");
            ImageProcessor ip = img_out.getProcessor();
            ip.flipVertical();           
            outFile.saveAsText(directory+"00 Scatter plot.txt"); // save the image data also as text file for the gnuplot script

            imagename = "00 Scatter plot";
            filename = "scatterscript.plt";
            tp = gs.scatterScript(imagename);                    
            tp.saveAs(directory+filename); // end of scatterscript.plt
            } // end of job=3 (scatter plot)
        
        return true;
        } // end of basicAnalysis()

    
    public boolean subtractHistos() // do all calculations and create the output files
	    {
        if ((nFiles % 2)!=0)
    		{
        	IJ.error("Number of files has to be even for subtraction of histograms.");
        	return false;
    		}

        TextPanel tp; // content of the output files
	    String imagename = ""; // name of the images created by the gnuplot scripts
	    String filename = ""; // name of the gnuplot script
	    Ratio_InOut rio = new Ratio_InOut(nFiles, directory);
	    Gnu_Scripts gs = new Gnu_Scripts(plottitle, axislabel, terminal, sd, screen, svg, png, nFiles, xTitle);
	    int c=0;
	
		double[][][] data = rio.loadHistoFiles(); // all histogram files; [Mean/SEM][bins][files]
	    if (data==null) return false;
	    double[][] result = new double[data[0].length][nFiles/2]; // subtraction
	    double[][] sem = new double[data[0].length][nFiles/2]; // standard errors
	    
	    for (int i=0; i<data[0].length; i++) // go through bins
	        {
	    	c=0;
	    	for (int j=0; j<data[0][0].length; j+=2)
	    		{
	    		result[i][c] = data[0][i][j+1]-data[0][i][j];
	        	// Sum of two values X,Y with uncertainties sX,sY:        e = SQRT((sX/2)^2 + (sY/2)^2))
        		sem[i][c] = Math.sqrt(Math.pow(data[1][i][j+1]/2,2)+Math.pow(data[1][i][j]/2,2));    
	        	c++;
	    		}
	        }
	
	    ResultsTable rt = ResultsTable.getResultsTable(); // for the output data
	    rt.setPrecision(9);
	    String filename2 = "";
	    
	    for (int j=0; j<c; j++)
	    	{
	    	filename = "histoscript"+(j+1)+".plt";
		    if (j<9) imagename = "0"+(j+1)+" Histogram";
		    else imagename = (j+1)+" Histogram";
		
		    rt.reset();
		    for (int i=0; i<result.length; i++)
		        {
		        rt.incrementCounter();
		        rt.addValue("Frequency", result[i][j]);    
		        rt.addValue("SEM", sem[i][j]);    
		        }
		   filename2=imagename+" Subtracted.xls";
		    try
		        {
		    	rt.saveAs(directory+filename2);    
		        }
		    catch (IOException e) 
		        {
		        IJ.error(saveError); 
		        return false;
		        } 

		    tp = gs.histoScript(imagename, filename2, true);
		    tp.saveAs(directory+filename); // write script to file  
	    	}
	
	    return true;
	    } // end of subtractHistos()
    
    
    public boolean compAnalysis() // Comparative statistics, i.e. compare several situations
        {
        TextPanel tp; // content of the output files
        String imagename = ""; // name of the images created by the gnuplot scripts
        String filename = ""; // name of the gnuplot script
        Ratio_InOut rio = new Ratio_InOut(nFiles, directory);
        Gnu_Scripts gs = new Gnu_Scripts(plottitle, axislabel, terminal, sd, screen, svg, png, nFiles, xTitle);

        // files created:
        // 00 Statistics Summary 1-1.xls - list of data from all files, one file per line: Min,Q1,Median,Q3,Max
        // 00 Statistics Summary 3.xls   - list of data from all files, three lines per file (arranged in groups): Min,Q1,Median,Q3,Max. 1st group: Standard results, 2nd group: SEM/MADs, 3rd group: Combined results. Groups are separated by "0"s
        // 00 Statistics Summary 2.xls   - list of data from all files, three lines per file: Value, SEM/MAD. 1st line: Quartile 1, 2nd line: Median, 3rd line: Quartile 3. Groups are separated by "0"s
        // 00 Statistics Summary 1-2.xls - list of data from all files, one line per file: Min, SEM/MAD (only if sd=true)
        // 00 Statistics Summary 1-3.xls - list of data from all files, one line per file: Q1, SEM/MAD (only if sd=true)
        // 00 Statistics Summary 1-4.xls - list of data from all files, one line per file: Med, SEM/MAD (only if sd=true)
        // 00 Statistics Summary 1-5.xls - list of data from all files, one line per file: Q3, SEM/MAD (only if sd=true)
        // 00 Statistics Summary 1-6.xls - list of data from all files, one line per file: Max, SEM/MAD (only if sd=true)
        // 00 Statistics Summary 4.xls - Statistical tests based on 'XX Statistics Summary 4.xls' files
        // statscript1.plt - GnuPlot script box-whisker plot
        // statscript2.plt - GnuPlot script box plot
        // statscript3.plt - GnuPlot script box-whisker plot without min/max

        // create 00 Statistics Summary 1-1.xls - list of data from all files, one file per line: Min,Q1,Median,Q3,Max
        // read and combine data from all 'XX Statistics Summary 1-1.xls' files
        double[][] data = rio.loadStatFiles(1, 5, true, " Summary 1-1", false); // read 1 line per file, 5 columns per file, inverse format: data = [files][data], add " Summary 1-1" to the input name, don't just get the median but all data
        if (data==null) return false;

        ResultsTable rt = ResultsTable.getResultsTable(); 
        rt.reset();
        rt.setPrecision(9);
                   
        for (int i=0; i<data.length; i++)
            {
            rt.incrementCounter();
            rt.addValue("Min", data[i][0]);    
            rt.addValue("Q1", data[i][1]);    
            rt.addValue("Med", data[i][2]);    
            rt.addValue("Q3", data[i][3]);    
            rt.addValue("Max", data[i][4]);    
            }

        try
            {
            rt.saveAs(directory+"00 Statistics Summary 1-1.xls");    
            }
        catch (IOException e) 
            {
            IJ.error(saveError); 
            return false;
            } 
        int c = data[0].length; // needed later for 00 Statistics Summary 1-2 - 1-6.xls

        // create 00 Statistics Summary 3.xls - list of data from all files, three lines per file (arranged in groups): Min,Q1,Median,Q3,Max. 1st group: Standard results, 2nd group: SEM/MADs, 3rd group: Combined results. Groups are separated by "0"s
        // read and combine data from all 'XX Statistics Summary 3.xls' files
        data = rio.loadStatFiles(3, 5, true, " Summary 3", false); // read 3 lines per file, 5 columns per file, inverse format: data = [files][data], add " Summary 3" to the input name, don't just get the median but all data
        if (data==null) return false;
        rt.reset();
                   
        for (int j=0; j<data[0].length; j+=5)
            {
            for (int l=0; l<nFiles; l++)
                {
                rt.incrementCounter();
                rt.addValue("Min", data[l][j]);    
                rt.addValue("Q1", data[l][j+1]);    
                rt.addValue("Med", data[l][j+2]);    
                rt.addValue("Q3", data[l][j+3]);    
                rt.addValue("Max", data[l][j+4]);    
                }
            rt.incrementCounter(); // add a line of "0"s in between groups
            rt.addValue("Min", 0);    
            rt.addValue("Q1", 0);    
            rt.addValue("Med", 0);    
            rt.addValue("Q3", 0);    
            rt.addValue("Max", 0);    
            }

        try
            {
            rt.saveAs(directory+"00 Statistics Summary 3.xls");    
            }
        catch (IOException e) 
            {
            IJ.error(saveError); 
            return false;
            } 

        // create 00 Statistics Summary 2.xls - list of data from all files, three lines per file: Value, SEM/MAD. 1st line: Quartile 1, 2nd line: Median, 3rd line: Quartile 3. Groups are separated by "0"s
        // read and combine data from all 'XX Statistics Summary 2.xls' files
        data = rio.loadStatFiles(3, 2, true, " Summary 2", false); // read 3 lines per file, 2 columns per file, inverse format: data = [files][data], add " Summary 2" to the input name, don't just get the median but all data
        if (data==null) return false;
        rt.reset();

        for (int j=0; j<data[0].length; j+=2)
            {
            for (int l=0; l<nFiles; l++)
                {
                rt.incrementCounter();
                rt.addValue("Median", data[l][j]);    
                rt.addValue("SEM/MAD", data[l][j+1]);
                }
            rt.incrementCounter(); // add a line of "0"s in between groups
            rt.addValue("Median", 0);    
            rt.addValue("SEM/MAD", 0);
            }

        try
            {
            rt.saveAs(directory+"00 Statistics Summary 2.xls");    
            }
        catch (IOException e) 
            {
            IJ.error(saveError); 
            return false;
            } 

        // create 00 Statistics Summary 1-2 - 1-6.xls - list of data from all files, one line per file: Value, SEM/MAD
        if (sd) // only if uncertainties shall be calculated/plotted
            {            
            for (int i=0; i<c; i++) // do this for as many values as exist in 00 Statistics Summary 1-1.xls
                {
                data = rio.loadStatFiles(1, 2, true, " Summary 1-"+(i+2)+"", false); // read 1 line per file, 2 columns per file, inverse format: data = [files][data], add " Summary 1-(i+2)" to the input name, don't just get the median but all data
                if (data==null) return false;
                rt.reset();
                for (int j=0; j<data.length; j++)
                    {
                    rt.incrementCounter();
                    rt.addValue("Median", data[j][0]);    
                    rt.addValue("SEM/MAD", data[j][1]);    
                    }
                try
                    {
                    rt.saveAs(directory+"00 Statistics Summary 1-"+(i+2)+".xls");    
                    }
                catch (IOException e) 
                    {
                    IJ.error(saveError); 
                    return false;
                    } 
                }
            }

        // create 00 Statistics Summary 4.xls - Statistical tests based on 'XX Statistics Summary 4.xls' files
        // the use of ArrayLists is necessary because the different files can contain different amounts of samples
        ArrayList<ArrayList<Double>> dList = rio.loadStatList(" Summary 4", 0); // read 'XX Statistics Summary 4.xls' files, read median 
        if (dList==null) return false;
        Ratio_Statistics rs = new Ratio_Statistics(nFiles, directory, xTitle);
        boolean success = rs.statTestMWU(dList, ""); // do statistical tests and write the file, median
        if (!success) return false;

        // create gnuplot script 1: box-whisker plot
        imagename = "00 Statistics 1";
        filename = "statscript1.plt";
        tp = gs.statScriptC1(imagename);                    
        tp.saveAs(directory+filename); // end of statscript1.plt

        // create gnuplot script 2: box plot
        imagename = "00 Statistics 2";
        filename = "statscript2.plt";
        tp = gs.statScriptC2(imagename);                    
        tp.saveAs(directory+filename); // end of statscript2.plt

        // create gnuplot script 3: box-whisker plot without min/max
        imagename = "00 Statistics 3";
        filename = "statscript3.plt";
        tp = gs.statScriptC3(imagename);                    
        tp.saveAs(directory+filename); // end of statscript3.plt
        
        return true;
        } // end of job 4, comparative statistics

    
    public boolean normAnalysis() // normalized statistics
        {
        TextPanel tp; // content of the output files
        String imagename = ""; // name of the images created by the gnuplot scripts
        String filename = ""; // name of the gnuplot script
        Ratio_InOut rio = new Ratio_InOut(nFiles, directory);
        Gnu_Scripts gs = new Gnu_Scripts(plottitle, axislabel, terminal, sd, screen, svg, png, nFiles, xTitle);
        
        // normalize a set of files to a reference.
        // EXAMPLE: 
        // first set: ratios within a complete neuropil. 
        // second set: subset of ratios (e.g. positive for GFP) within that neuropil.   

        // files created:
        // 2x 00 Statistics Summary XX 3.xls   - Min,Q1,Median,Q3,Max. 1st line: Standard results, 2nd line: SEM/MADs, 3rd line: Combined results
        // 2x 00 Statistics Summary XX 1-1.xls - Min,Q1,Median,Q3,Max. 1st line: Standard results, 2nd line: SEM/MADs
        // 2x 00 Statistics Summary XX 2.xls   - Value, SEM/MAD. 1st line: Quartile 1, 2nd line: Median, 3rd line: Quartile 3. 
        // 2x 00 Statistics Summary XX 1-2.xls - Min, SEM/MAD
        // 2x 00 Statistics Summary XX 1-3.xls - Q1, SEM/MAD
        // 2x 00 Statistics Summary XX 1-4.xls - Med, SEM/MAD
        // 2x 00 Statistics Summary XX 1-5.xls - Q3, SEM/MAD
        // 2x 00 Statistics Summary XX 1-6.xls - Max, SEM/MAD
        // 2x statscript1_XXX.plt - GnuPlot script box-whisker plot
        // 2x statscript2_XXX.plt - GnuPlot script box plot
        
        // read all data
        String dirTemp = directory;
        directory = dirTemp+refFiles[1]+"/"; // get the first set (complete neuropil)          
        double[][] neuropil = rio.loadStatFiles(1, 5, false, "", false); // read 1 line per file, 5 columns per file, don't use inverse format: data = [data][files], don't add a string to the input name, don't just get the median but all data
        if (neuropil==null) return false;
        directory = dirTemp+refFiles[2]+"/"; // get the second set (positive for GFP)           
        double[][] signal = rio.loadStatFiles(1, 5, false, "", false); // read 1 line per file, 5 columns per file, don't use inverse format: data = [data][files], don't add a string to the input name, don't just get the median but all data
        if (signal==null) return false;
        directory = dirTemp;
        double[][] corrS = new double[neuropil.length][neuropil[0].length]; // for final values, signal, second set)

        // normalize
        for (int i=0; i<neuropil.length; i++)
            {
            for (int j=0; j<neuropil[0].length; j++)
                {
                corrS[i][j] = signal[i][j]/neuropil[i][j]; // normalize the second set by the first set
                }
            }

        // Calculate median/mean values and errors/deviations
        // first line: standard results // second line: combined results // third line: inverted results
        // combined results: 
        // show the original value if 0<=value<=1, otherwise 1 + (1 - the inverted value)
        // this way values are uniformly distributed around 1
        // The original values are used for statistics (standard results, line 1)
        double[] median = new double[neuropil.length];
        double[] medianS = new double[neuropil.length];
        double[] medianR = new double[neuropil.length];
        double[] semS = new double[neuropil.length];
        double[] semR = new double[neuropil.length];
        double[] invMed = new double[neuropil.length];

        for (int i=0; i<neuropil.length; i++) // calculate errors
            {
            if (statsMean)
            	{
                median[i] = Ratio_Statistics.getMean(corrS[i]);
                medianS[i] = Ratio_Statistics.getMean(signal[i]);
                medianR[i] = Ratio_Statistics.getMean(neuropil[i]);
                semS[i] = Ratio_Statistics.getSD(signal[i], medianS[i])/Math.sqrt((double)signal[0].length); // calculate standard error of the mean
                semR[i] = Ratio_Statistics.getSD(neuropil[i], medianR[i])/Math.sqrt((double)neuropil[0].length); // calculate standard error of the mean
            	}
            else
            	{
                median[i] = Ratio_Statistics.getMedian(corrS[i], true);
                medianS[i] = Ratio_Statistics.getMedian(signal[i], true);
                medianR[i] = Ratio_Statistics.getMedian(neuropil[i], true);
	            
                if (stats_mad) // use MAD
	                {
	                double[] madS = new double[neuropil.length];
	                double[] madR = new double[neuropil.length];
	                for (int j=0; j<neuropil[0].length; j++) // calc median absolute deviation (mad)
	                    {
	                    madS[j] = Math.abs(medianS[i]-signal[i][j]); // the difference between the individual values in each file and the median
	                    madR[j] = Math.abs(medianR[i]-neuropil[i][j]); // the difference between the individual values in each file and the median
	                    }
	                semS[i] = Ratio_Statistics.getMedian(madS, true);               
	                semR[i] = Ratio_Statistics.getMedian(madR, true);               
	                }
	            else // use standard error of the median
	                {
	                semS[i] = Ratio_Statistics.getSEMed(signal[i]); // get standard error of the median                      
	                semS[i] = Ratio_Statistics.getSEMed(neuropil[i]); // get standard error of the median                      
	                }
            	}

            if (median[i]<((1.0d/255.0d)/4.0d)) median[i]=(1.0d/255.0d)/4.0d; // catch min value
            else if (median[i]>255.0d*4.0d) median[i]=255.0d*4.0d; // catch max value               

            if (median[i]>=2) invMed[i] = 255;
            else if (median[i]>1) invMed[i] = 1+(1-(1.0d/median[i]));
            else invMed[i] = median[i];
            } // end of for()

        // calculate final uncertainties
        // NOTE: Error propagation according to: Lothar Papula, Mathematik für Ingenieure und Naturwissenschaftler Band 3, 5. Auflage 2008, Kapitel 4.3, Seite 678ff: Gaußsches Fehlerfortpflanzungsgesetz
        // Division of two values X,Y with uncertainties sX,sY:        e = SQRT((sX/X)^2 + (sY/Y)^2))
        double[] sem = new double[neuropil.length];
        for (int i=0; i<neuropil.length; i++)
            {
            sem[i] = Math.sqrt(Math.pow(semS[i]/medianS[i],2)+Math.pow(semR[i]/semR[i],2));    
            }
        
        // create 00 Statistics Summary 3.xls - Min,Q1,Median,Q3,Max. 1st line: Standard results, 2nd line: SEM/MADs, 3rd line: Combined results
        ResultsTable rt = ResultsTable.getResultsTable(); // final normalized values (signal, second set, '‚Ä¶S[]')
        rt.reset();
        rt.setPrecision(9);
        
        rt.incrementCounter();
        rt.addValue("Min", median[0]);    
        rt.addValue("Q1", median[1]);    
        rt.addValue("Med", median[2]);    
        rt.addValue("Q3", median[3]);    
        rt.addValue("Max", median[4]);    
        rt.incrementCounter();
        rt.addValue("Min", sem[0]);    
        rt.addValue("Q1", sem[1]);    
        rt.addValue("Med", sem[2]);    
        rt.addValue("Q3", sem[3]);    
        rt.addValue("Max", sem[4]);    
        rt.incrementCounter();
        rt.addValue("Min", invMed[0]);    
        rt.addValue("Q1", invMed[1]);    
        rt.addValue("Med", invMed[2]);    
        rt.addValue("Q3", invMed[3]);    
        rt.addValue("Max", invMed[4]);  

        try
            {
            rt.saveAs(directory+"00 Statistics Summary 3.xls");    
            }
        catch (IOException e) 
            {
            IJ.error(saveError); 
            return false;
            } 

        // create 00 Statistics Summary 1-1.xls - Min,Q1,Median,Q3,Max. 1st line: Standard results, 2nd line: SEM/MADs
        rt.reset();

        rt.incrementCounter();
        rt.addValue("Min", median[0]);    
        rt.addValue("Q1", median[1]);    
        rt.addValue("Med", median[2]);    
        rt.addValue("Q3", median[3]);    
        rt.addValue("Max", median[4]);    

        rt.incrementCounter();
        rt.addValue("Min", sem[0]);    
        rt.addValue("Q1", sem[1]);    
        rt.addValue("Med", sem[2]);    
        rt.addValue("Q3", sem[3]);    
        rt.addValue("Max", sem[4]);    

        try
            {
            rt.saveAs(directory+"00 Statistics Summary 1-1.xls");    
            }
        catch (IOException e) 
            {
            IJ.error(saveError); 
            return false;
            } 

        // create 00 Statistics Summary 2.xls - Value, SEM/MAD. 1st line: Quartile 1, 2nd line: Median, 3rd line: Quartile 3. 
        rt.reset();
        for (int i=1; i<medianS.length-1; i++)
            {
            rt.incrementCounter();
            if(statsMean) rt.addValue("Mean", median[i]);
            else rt.addValue("Median", median[i]);
            if (stats_mad) rt.addValue("MAD", sem[i]);
            else rt.addValue("SEM", sem[i]);
            }
        try
            {
            rt.saveAs(directory+"00 Statistics Summary 2.xls");    
            }
        catch (IOException e) 
            {
            IJ.error(saveError); 
            return false;
            } 

        // create 00 Statistics Summary 1-2 - 1-6.xls - Value, SEM/MAD
        if (sd) // if uncertainties should be calculated/plotted
            {            
            for (int i=0; i<medianS.length; i++)
                {
                rt.reset();
                rt.incrementCounter();
                if(statsMean) rt.addValue("Mean", median[i]);
                else rt.addValue("Median", median[i]);
                if (stats_mad) rt.addValue("MAD", sem[i]);
                else rt.addValue("SEM", sem[i]);
                    
                try
                    {
                    rt.saveAs(directory+"00 Statistics Summary 1-"+(i+2)+".xls");    
                    }
                catch (IOException e) 
                    {
                    IJ.error(saveError); 
                    return false;
                    } 
                }
            }

        // create gnuplot script 1: box-whisker plot
        imagename = "00 Statistics 1";
        filename = "statscript1.plt";
        tp = gs.statScriptC1(imagename);                    
        tp.saveAs(directory+filename); // end of statscript1.plt

        // create gnuplot script 2: box plot
        imagename = "00 Statistics 2";
        filename = "statscript2.plt";
        tp = gs.statScriptC2(imagename);                    
        tp.saveAs(directory+filename); // end of statscript2.plt

        // create gnuplot script 3: box-whisker plot without min/max
        imagename = "00 Statistics 3";
        filename = "statscript3.plt";
        tp = gs.statScriptC3(imagename);                    
        tp.saveAs(directory+filename); // end of statscript3.plt
        
        return true; 
        }  // end of job 5, normalized statistics


    public ImagePlus averagePlots(ImagePlus[] imp_in) // average scatter plots; imp_in contains all the scatter plots
        {
        ImageProcessor[] ip = new ImageProcessor[imp_in.length];
        int width  = imp_in[0].getWidth(); 
        int height = imp_in[0].getHeight();
        int size = width*height;       

        String imp_out_title = "Average scatter plot"; // create a title for the output image
        ImagePlus imp_out = NewImage.createFloatImage(imp_out_title, width, height, 1, 1);
        if (imp_out == null) // produce an error if this fails
            {
            IJ.error(title, "Oops, out of memory...");
            return null;
            }
        WindowManager.checkForDuplicateName = true; // add a number to the title if name already exists  
        float[][] pixels_in = new float[imp_in.length][size]; // will contain all input data

        for (int i=0; i<imp_in.length; i++) // cycle through all scatter plots and read the data
            {
            ip[i] = imp_in[i].getProcessor();               
            pixels_in[i] = (float[])ip[i].getPixels();                
            }

        // do the averaging
        double[] pixels_out = new double[size];
        double value, sum, newPixel; // value = final value per position, sum = sum of pixel values, newPixel = new pixel value
        for (int i=0; i<size; i++) 
            {
            sum = 0.0d;
            for (int j=0; j<imp_in.length; j++) // sum up all frequencies at each pixel/position 
                {
                newPixel = (double)pixels_in[j][i]; // get new data
                sum += newPixel; // add it
                }
            value = sum/imp_in.length; // calculate the average
            pixels_out[i] = value;
            }
        
        // generate the output image
        ImageProcessor ip_out = new FloatProcessor(width, height, pixels_out); // create the output image
		ip_out.setColorModel(ip[0].getCurrentColorModel()); // apply the LUT
        ImageStatistics iSt = new ImageStatistics(); // find the max value
        iSt = ImageStatistics.getStatistics(ip_out, 16, null); // Get raw MIN_MAX
        ip_out.setMinAndMax(0,iSt.max); // scale the LUT
        imp_out.setProcessor(null, ip_out);
        imp_out.copyScale(imp_in[0]);
        WindowManager.setTempCurrentImage(imp_out); 
        IJ.run("Fire"); // change the lookup table

        return imp_out;
        } // end of averagePlots() (scatter)

        
    private boolean fileDialog() // ask the user what to do
        {
        String[] purpose_temp = new String[10]; // which analyses to run
        purpose_temp[0] = "Basic Statistics: Mean Histogram";
        purpose_temp[1] = "Basic Statistics: Mean Statistics";
        purpose_temp[2] = "Basic Statistics: Mean Scatterplot";
        purpose_temp[3] = "Basic Statistics: All three plots (Histogram, Statistics, Scatterplot)";
        purpose_temp[4] = "Basic Statistics: Generate overview of all histograms";
        purpose_temp[5] = "Additional Statistics: Compare groups";
        purpose_temp[6] = "Additional Statistics: Ratio of two groups";
        purpose_temp[7] = "Additional Statistics: Generate Fingerprint image";
        purpose_temp[8] = "Additional Statistics: Calculate relative distribution (low-balanced-high)";
        purpose_temp[9] = "Additional Statistics: Subtract two histograms";

        String[] terminalC = new String[4]; // terminal for GnuPlot
        terminalC[0] = "aqua";
        terminalC[1] = "x11";
        terminalC[2] = "windows";
        terminalC[3] = "wxt";

        if (statsMean) statsMean=false; // statsMean=true calculates means instead of medians but the question is asked the other way round.
        else statsMean=true;     
        
        // create the dialog
        GenericDialog gd = new GenericDialog(title);
        gd.addChoice("What do you want to plot:", purpose_temp, purpose_temp[job]);
        gd.addNumericField("Number of input files:", nFiles, 0);
//        gd.addNumericField("Arrange comparative statistics in groups of:", 3, 0); // DISABLED
		gd.setInsets(40,20,0);
        gd.addCheckbox("Calculate Standard Errors", sd);       
        gd.addCheckbox("Use Median instead of Mean for Statistics", statsMean);              
        gd.addCheckbox("Use Median instead of Mean for Histograms", histo_med);              
		gd.setInsets(10,20,0);
        gd.addMessage("When using medians, Standard Error of the Median is used for calculating errors of Statistics files.");
        gd.addCheckbox("Use Median Absolute Deviation instead of the Standard Error of the Median", stats_mad);              
		gd.setInsets(40,20,0);
        gd.addCheckbox("Enter directory for saving files manually", false);
        gd.addStringField("Directory:", directory, 30);
		gd.setInsets(40,20,10);
        gd.addMessage("Options regarding the gnuplot scripts:");
        gd.addStringField("Title of plot:", plottitle, 30);
        gd.addStringField("X axis label:", axislabel, 30);
		gd.setInsets(10,20,0);
        gd.addCheckbox("Display results on screen when executing gnuplot scripts", screen);
		gd.setInsets(0,20,0);
        gd.addChoice("Which terminal do you want to use for display:", terminalC, terminal);
		gd.setInsets(0,20,20);
        gd.addMessage("\'aqua\' is recommended for OS X, \'windows\' for Windows");
        gd.addCheckbox("Create .svg file", svg);
        gd.addCheckbox("Create .png file", png);
		gd.setInsets(40,20,0);
        gd.addMessage("Files to be processed by the script need to follow this pattern:");
		gd.setInsets(0,20,0);
        gd.addMessage("\"01 Filename.xls\", \"02 Filename.xls\" etc.");
        gd.showDialog();
        if (gd.wasCanceled())  return false;
        
        int tempJob = gd.getNextChoiceIndex();
        if (tempJob==4) job=6; // histogram overview
        else if (tempJob==5) job=4; // compare groups
        else if (tempJob==6) job=5; // normalize
        else job=tempJob; // other cases
        
        int termID = gd.getNextChoiceIndex();
        nFiles = (int)gd.getNextNumber();
        if (nFiles == 0) return false;
        sd = gd.getNextBoolean();
        statsMean = gd.getNextBoolean();
        if (statsMean) statsMean=false; // statsMean=true calculates means instead of medians but the question is asked the other way round.
        else statsMean=true;
        histo_med = gd.getNextBoolean();
        stats_mad = gd.getNextBoolean();
        boolean manual = gd.getNextBoolean();
        screen = gd.getNextBoolean();
        svg = gd.getNextBoolean();
        png = gd.getNextBoolean();
        String dirtemp = gd.getNextString();
        plottitle = gd.getNextString();
        axislabel = gd.getNextString();

        switch (termID) // get the gnuplot terminal
            {
            case 0: terminal = terminalC[0];   
                    break;
            case 1: terminal = terminalC[1];   
                    break;
            case 2: terminal = terminalC[2];   
                    break;
            case 3: terminal = terminalC[3];   
                    break;
            }

        if (job==3) all=true; // run all basic analyses     
        
        if (job==0 || job==1 || job==3 || job==5) // if histogram or statistics shall be calculated
            {
            if (!statsMean && nFiles<4 && (!stats_mad || histo_med))
                {
                IJ.showMessage("Standard error of the median can only be calculated with data from at least 4 files; switching to means (histogram) and MAD (statistics) instead.");
                stats_mad = true;
                histo_med = false;
                }     
            }
        
        if (job==7) // choose file
        	{
        	OpenDialog od;
           	od = new OpenDialog("Please choose your input file:", null);
        	directory = od.getDirectory();
        	inputFile = od.getFileName();
        	if (directory==null) return false;
        	}
        else if(!manual)
            {
            DirectoryChooser sd = new DirectoryChooser("Location of files:");
            directory = sd.getDirectory();
            if (directory==null) return false;
            }
        else
            {
            directory = dirtemp;
            }       
        
        if (job==4) // comparative statistics
            { // show another dialog for the x-labels
            if (nFiles<2) return false;
            String[] field_temp = new String[nFiles];
            field_temp[0] = ""; // create the text fields for the x-labels
            field_temp[1] = "";
            if (nFiles>2) field_temp[2] = "";
            if (nFiles>3)
                {
                for (int i=3; i<nFiles; i++)
                    {
                    field_temp[i] = "";
                    }                   
                }
            
            gd = new GenericDialog(title);
            gd.addMessage("Choose x-labels:");
            for (int i=1; i<=nFiles; i++)
                {
                gd.addStringField("File "+i+":", field_temp[i-1], 30);
                }

            gd.showDialog();
            if (gd.wasCanceled())  return false;

            xTitle = new String[nFiles]; // get the x-labels
            for (int i=0; i<nFiles; i++)
                {
                xTitle[i] = gd.getNextString();
                }
            }

        if (job==5) // normalized statistics
            {
            gd = new GenericDialog(title); // get the necessary input files
            gd.addMessage("Files and Subdirectories:");
            gd.addStringField("Folder containing references:", "calyx", 30);
            gd.addStringField("Folder to be processed:", "gfp", 30);

            gd.showDialog();
            if (gd.wasCanceled())  return false;

            refFiles = new String[2];
            refFiles[0] = gd.getNextString();
            refFiles[1] = gd.getNextString();
            }

        if (job==6) // only create histogram overview
            {
            job = 0;
            overview = true;
            }
        
        return true;
        } // end of fileDialog()
    } 